
// FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容,
// 使用 File 或 Blob 对象指定要读取的文件或数据。
// 开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象.
reader = new window.FileReader()
reader.readAsArrayBuffer(file)

//  返回对象的可枚举属性和方法的名称。
Object.keys(params)

// 内置对象获取地址栏的参数 通过键的方式拿到值
let productId = new URLSearchParams(window.location.search).get('id');

event.preventDefault() // 防止链接打开 URL：


// 添加"load"事件, 窗口加载时, 调用函数
window.addEventListener('load', function () {
    window.web3 = new Web3(new Web3.providers.HttpProvider(ethereumNodeUrl));
    App.start();
});

then(() => inst.productIndex())  // 无需参数, 直接调用函数, 得到返回值, 再进行传递

// 渲染页面
then(p => $("#product-list").append(buildProduct(p)))
 

// EC6 读取数据, 写入到html中
`${ipfsGatewayUrl}/ipfs/${product[3]}`

/*
Buffer(缓冲区)
    JavaScript 语言自身只有字符串数据类型, 没有二进制数据类型。
    但在处理像TCP流或文件流时, 必须使用到二进制数据

Buffer 实例一般用于表示编码字符的序列, 比如 UTF - 8、 UCS2、 Base64、 或十六进制编码的数据。 
通过使用显式的字符编码, 就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。

创建Buffer类
    Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（ 传入的 array 的元素只能是数字, 不然就会自动被 0 覆盖）
    Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。
    Buffer.from(buffer)： 复制传入的 Buffer 实例的数据, 并返回一个新的 Buffer 实例
    Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例

写入
    buf.write(string[, offset[, length]][, encoding])
读取
    buf.toString([encoding[, start[, end]]]) / buf.toJSON()
合并
    Buffer.concat(list[, totalLength])
比较
    buf.compare(otherBuffer);
...
*/

// Date.parse()函数用于分析一个包含日期的字符串,并返回该日期与 1970 年 1 月 1 日午夜之间相差的毫秒数。
Date.parse(params["product-auction-start"]) / 1000;
/*
处理整数的时候parseInt() 更常用。 parseInt() 函数在转换字符串时, 会忽略字符串前面的空格, 直到找到第一个非空格字符。
如果第一个字符不是数字或者负号, parseInt() 就会返回NaN, 同样的, 用parseInt() 转换空字符串也会返回NaN。
如果第一个字符是数字字符, parseInt() 会继续解析第二个字符, 直到解析完所有后续字符串或者遇到了一个非数字字符。
*/
